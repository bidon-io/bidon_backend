// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package event

import (
	"context"
	"sync"
)

// Ensure, that LoggerEngineMock does implement LoggerEngine.
// If this is not the case, regenerate this file with moq.
var _ LoggerEngine = &LoggerEngineMock{}

// LoggerEngineMock is a mock implementation of LoggerEngine.
//
//	func TestSomethingThatUsesLoggerEngine(t *testing.T) {
//
//		// make and configure a mocked LoggerEngine
//		mockedLoggerEngine := &LoggerEngineMock{
//			ProduceFunc: func(ctx context.Context, topic Topic, message []byte, handleErr func(error))  {
//				panic("mock out the Produce method")
//			},
//		}
//
//		// use mockedLoggerEngine in code that requires LoggerEngine
//		// and then make assertions.
//
//	}
type LoggerEngineMock struct {
	// ProduceFunc mocks the Produce method.
	ProduceFunc func(ctx context.Context, topic Topic, message []byte, handleErr func(error))

	// calls tracks calls to the methods.
	calls struct {
		// Produce holds details about calls to the Produce method.
		Produce []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic Topic
			// Message is the message argument value.
			Message []byte
			// HandleErr is the handleErr argument value.
			HandleErr func(error)
		}
	}
	lockProduce sync.RWMutex
}

// Produce calls ProduceFunc.
func (mock *LoggerEngineMock) Produce(ctx context.Context, topic Topic, message []byte, handleErr func(error)) {
	if mock.ProduceFunc == nil {
		panic("LoggerEngineMock.ProduceFunc: method is nil but LoggerEngine.Produce was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Topic     Topic
		Message   []byte
		HandleErr func(error)
	}{
		Ctx:       ctx,
		Topic:     topic,
		Message:   message,
		HandleErr: handleErr,
	}
	mock.lockProduce.Lock()
	mock.calls.Produce = append(mock.calls.Produce, callInfo)
	mock.lockProduce.Unlock()
	mock.ProduceFunc(ctx, topic, message, handleErr)
}

// ProduceCalls gets all the calls that were made to Produce.
// Check the length with:
//
//	len(mockedLoggerEngine.ProduceCalls())
func (mock *LoggerEngineMock) ProduceCalls() []struct {
	Ctx       context.Context
	Topic     Topic
	Message   []byte
	HandleErr func(error)
} {
	var calls []struct {
		Ctx       context.Context
		Topic     Topic
		Message   []byte
		HandleErr func(error)
	}
	mock.lockProduce.RLock()
	calls = mock.calls.Produce
	mock.lockProduce.RUnlock()
	return calls
}
