// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bidon-io/bidon-backend/internal/admin/auth"
	"github.com/bidon-io/bidon-backend/internal/db"
	"sync"
)

// Ensure, that UserServiceMock does implement auth.UserService.
// If this is not the case, regenerate this file with moq.
var _ auth.UserService = &UserServiceMock{}

// UserServiceMock is a mock implementation of auth.UserService.
//
//	func TestSomethingThatUsesUserService(t *testing.T) {
//
//		// make and configure a mocked auth.UserService
//		mockedUserService := &UserServiceMock{
//			ComparePasswordFunc: func(storedPasswordHash string, password string) bool {
//				panic("mock out the ComparePassword method")
//			},
//			CreateUserFunc: func(email string, password string) (*db.User, error) {
//				panic("mock out the CreateUser method")
//			},
//			GetUserByEmailFunc: func(email string) (*db.User, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//		}
//
//		// use mockedUserService in code that requires auth.UserService
//		// and then make assertions.
//
//	}
type UserServiceMock struct {
	// ComparePasswordFunc mocks the ComparePassword method.
	ComparePasswordFunc func(storedPasswordHash string, password string) bool

	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(email string, password string) (*db.User, error)

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(email string) (*db.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// ComparePassword holds details about calls to the ComparePassword method.
		ComparePassword []struct {
			// StoredPasswordHash is the storedPasswordHash argument value.
			StoredPasswordHash string
			// Password is the password argument value.
			Password string
		}
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// Email is the email argument value.
			Email string
			// Password is the password argument value.
			Password string
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Email is the email argument value.
			Email string
		}
	}
	lockComparePassword sync.RWMutex
	lockCreateUser      sync.RWMutex
	lockGetUserByEmail  sync.RWMutex
}

// ComparePassword calls ComparePasswordFunc.
func (mock *UserServiceMock) ComparePassword(storedPasswordHash string, password string) bool {
	if mock.ComparePasswordFunc == nil {
		panic("UserServiceMock.ComparePasswordFunc: method is nil but UserService.ComparePassword was just called")
	}
	callInfo := struct {
		StoredPasswordHash string
		Password           string
	}{
		StoredPasswordHash: storedPasswordHash,
		Password:           password,
	}
	mock.lockComparePassword.Lock()
	mock.calls.ComparePassword = append(mock.calls.ComparePassword, callInfo)
	mock.lockComparePassword.Unlock()
	return mock.ComparePasswordFunc(storedPasswordHash, password)
}

// ComparePasswordCalls gets all the calls that were made to ComparePassword.
// Check the length with:
//
//	len(mockedUserService.ComparePasswordCalls())
func (mock *UserServiceMock) ComparePasswordCalls() []struct {
	StoredPasswordHash string
	Password           string
} {
	var calls []struct {
		StoredPasswordHash string
		Password           string
	}
	mock.lockComparePassword.RLock()
	calls = mock.calls.ComparePassword
	mock.lockComparePassword.RUnlock()
	return calls
}

// CreateUser calls CreateUserFunc.
func (mock *UserServiceMock) CreateUser(email string, password string) (*db.User, error) {
	if mock.CreateUserFunc == nil {
		panic("UserServiceMock.CreateUserFunc: method is nil but UserService.CreateUser was just called")
	}
	callInfo := struct {
		Email    string
		Password string
	}{
		Email:    email,
		Password: password,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(email, password)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockedUserService.CreateUserCalls())
func (mock *UserServiceMock) CreateUserCalls() []struct {
	Email    string
	Password string
} {
	var calls []struct {
		Email    string
		Password string
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *UserServiceMock) GetUserByEmail(email string) (*db.User, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("UserServiceMock.GetUserByEmailFunc: method is nil but UserService.GetUserByEmail was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedUserService.GetUserByEmailCalls())
func (mock *UserServiceMock) GetUserByEmailCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// Ensure, that TokenServiceMock does implement auth.TokenService.
// If this is not the case, regenerate this file with moq.
var _ auth.TokenService = &TokenServiceMock{}

// TokenServiceMock is a mock implementation of auth.TokenService.
//
//	func TestSomethingThatUsesTokenService(t *testing.T) {
//
//		// make and configure a mocked auth.TokenService
//		mockedTokenService := &TokenServiceMock{
//			GenerateAccessTokenFunc: func(email string) (string, error) {
//				panic("mock out the GenerateAccessToken method")
//			},
//		}
//
//		// use mockedTokenService in code that requires auth.TokenService
//		// and then make assertions.
//
//	}
type TokenServiceMock struct {
	// GenerateAccessTokenFunc mocks the GenerateAccessToken method.
	GenerateAccessTokenFunc func(email string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateAccessToken holds details about calls to the GenerateAccessToken method.
		GenerateAccessToken []struct {
			// Email is the email argument value.
			Email string
		}
	}
	lockGenerateAccessToken sync.RWMutex
}

// GenerateAccessToken calls GenerateAccessTokenFunc.
func (mock *TokenServiceMock) GenerateAccessToken(email string) (string, error) {
	if mock.GenerateAccessTokenFunc == nil {
		panic("TokenServiceMock.GenerateAccessTokenFunc: method is nil but TokenService.GenerateAccessToken was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	mock.lockGenerateAccessToken.Lock()
	mock.calls.GenerateAccessToken = append(mock.calls.GenerateAccessToken, callInfo)
	mock.lockGenerateAccessToken.Unlock()
	return mock.GenerateAccessTokenFunc(email)
}

// GenerateAccessTokenCalls gets all the calls that were made to GenerateAccessToken.
// Check the length with:
//
//	len(mockedTokenService.GenerateAccessTokenCalls())
func (mock *TokenServiceMock) GenerateAccessTokenCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	mock.lockGenerateAccessToken.RLock()
	calls = mock.calls.GenerateAccessToken
	mock.lockGenerateAccessToken.RUnlock()
	return calls
}
