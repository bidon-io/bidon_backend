// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package admin

import (
	"context"
	"sync"
)

// Ensure, that ResourceManipulatorMock does implement ResourceManipulator.
// If this is not the case, regenerate this file with moq.
var _ ResourceManipulator[any, any] = &ResourceManipulatorMock[any, any]{}

// ResourceManipulatorMock is a mock implementation of ResourceManipulator.
//
//	func TestSomethingThatUsesResourceManipulator(t *testing.T) {
//
//		// make and configure a mocked ResourceManipulator
//		mockedResourceManipulator := &ResourceManipulatorMock{
//			CreateFunc: func(ctx context.Context, attrs *ResourceAttrs) (*Resource, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the Delete method")
//			},
//			UpdateFunc: func(ctx context.Context, id int64, attrs *ResourceAttrs) (*Resource, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedResourceManipulator in code that requires ResourceManipulator
//		// and then make assertions.
//
//	}
type ResourceManipulatorMock[Resource any, ResourceAttrs any] struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, attrs *ResourceAttrs) (*Resource, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id int64) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, id int64, attrs *ResourceAttrs) (*Resource, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attrs is the attrs argument value.
			Attrs *ResourceAttrs
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
			// Attrs is the attrs argument value.
			Attrs *ResourceAttrs
		}
	}
	lockCreate sync.RWMutex
	lockDelete sync.RWMutex
	lockUpdate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) Create(ctx context.Context, attrs *ResourceAttrs) (*Resource, error) {
	if mock.CreateFunc == nil {
		panic("ResourceManipulatorMock.CreateFunc: method is nil but ResourceManipulator.Create was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Attrs *ResourceAttrs
	}{
		Ctx:   ctx,
		Attrs: attrs,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, attrs)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedResourceManipulator.CreateCalls())
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) CreateCalls() []struct {
	Ctx   context.Context
	Attrs *ResourceAttrs
} {
	var calls []struct {
		Ctx   context.Context
		Attrs *ResourceAttrs
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) Delete(ctx context.Context, id int64) error {
	if mock.DeleteFunc == nil {
		panic("ResourceManipulatorMock.DeleteFunc: method is nil but ResourceManipulator.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedResourceManipulator.DeleteCalls())
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) DeleteCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) Update(ctx context.Context, id int64, attrs *ResourceAttrs) (*Resource, error) {
	if mock.UpdateFunc == nil {
		panic("ResourceManipulatorMock.UpdateFunc: method is nil but ResourceManipulator.Update was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		ID    int64
		Attrs *ResourceAttrs
	}{
		Ctx:   ctx,
		ID:    id,
		Attrs: attrs,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, id, attrs)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedResourceManipulator.UpdateCalls())
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) UpdateCalls() []struct {
	Ctx   context.Context
	ID    int64
	Attrs *ResourceAttrs
} {
	var calls []struct {
		Ctx   context.Context
		ID    int64
		Attrs *ResourceAttrs
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that AuthContextMock does implement AuthContext.
// If this is not the case, regenerate this file with moq.
var _ AuthContext = &AuthContextMock{}

// AuthContextMock is a mock implementation of AuthContext.
//
//	func TestSomethingThatUsesAuthContext(t *testing.T) {
//
//		// make and configure a mocked AuthContext
//		mockedAuthContext := &AuthContextMock{
//			IsAdminFunc: func() bool {
//				panic("mock out the IsAdmin method")
//			},
//			UserIDFunc: func() int64 {
//				panic("mock out the UserID method")
//			},
//		}
//
//		// use mockedAuthContext in code that requires AuthContext
//		// and then make assertions.
//
//	}
type AuthContextMock struct {
	// IsAdminFunc mocks the IsAdmin method.
	IsAdminFunc func() bool

	// UserIDFunc mocks the UserID method.
	UserIDFunc func() int64

	// calls tracks calls to the methods.
	calls struct {
		// IsAdmin holds details about calls to the IsAdmin method.
		IsAdmin []struct {
		}
		// UserID holds details about calls to the UserID method.
		UserID []struct {
		}
	}
	lockIsAdmin sync.RWMutex
	lockUserID  sync.RWMutex
}

// IsAdmin calls IsAdminFunc.
func (mock *AuthContextMock) IsAdmin() bool {
	if mock.IsAdminFunc == nil {
		panic("AuthContextMock.IsAdminFunc: method is nil but AuthContext.IsAdmin was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsAdmin.Lock()
	mock.calls.IsAdmin = append(mock.calls.IsAdmin, callInfo)
	mock.lockIsAdmin.Unlock()
	return mock.IsAdminFunc()
}

// IsAdminCalls gets all the calls that were made to IsAdmin.
// Check the length with:
//
//	len(mockedAuthContext.IsAdminCalls())
func (mock *AuthContextMock) IsAdminCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsAdmin.RLock()
	calls = mock.calls.IsAdmin
	mock.lockIsAdmin.RUnlock()
	return calls
}

// UserID calls UserIDFunc.
func (mock *AuthContextMock) UserID() int64 {
	if mock.UserIDFunc == nil {
		panic("AuthContextMock.UserIDFunc: method is nil but AuthContext.UserID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUserID.Lock()
	mock.calls.UserID = append(mock.calls.UserID, callInfo)
	mock.lockUserID.Unlock()
	return mock.UserIDFunc()
}

// UserIDCalls gets all the calls that were made to UserID.
// Check the length with:
//
//	len(mockedAuthContext.UserIDCalls())
func (mock *AuthContextMock) UserIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUserID.RLock()
	calls = mock.calls.UserID
	mock.lockUserID.RUnlock()
	return calls
}

// Ensure, that resourcePolicyMock does implement resourcePolicy.
// If this is not the case, regenerate this file with moq.
var _ resourcePolicy[any, any] = &resourcePolicyMock[any, any]{}

// resourcePolicyMock is a mock implementation of resourcePolicy.
//
//	func TestSomethingThatUsesresourcePolicy(t *testing.T) {
//
//		// make and configure a mocked resourcePolicy
//		mockedresourcePolicy := &resourcePolicyMock{
//			authorizeCreateFunc: func(ctx context.Context, authCtx AuthContext, attrs *ResourceAttrs) error {
//				panic("mock out the authorizeCreate method")
//			},
//			authorizeDeleteFunc: func(ctx context.Context, authCtx AuthContext, resource *Resource) error {
//				panic("mock out the authorizeDelete method")
//			},
//			authorizeUpdateFunc: func(ctx context.Context, authCtx AuthContext, resource *Resource, attrs *ResourceAttrs) error {
//				panic("mock out the authorizeUpdate method")
//			},
//			getManageScopeFunc: func(authContext AuthContext) resourceScope[Resource] {
//				panic("mock out the getManageScope method")
//			},
//			getReadScopeFunc: func(authContext AuthContext) resourceScope[Resource] {
//				panic("mock out the getReadScope method")
//			},
//			instancePermissionsFunc: func(authContext AuthContext, v *Resource) ResourceInstancePermissions {
//				panic("mock out the instancePermissions method")
//			},
//			permissionsFunc: func(authContext AuthContext) ResourcePermissions {
//				panic("mock out the permissions method")
//			},
//		}
//
//		// use mockedresourcePolicy in code that requires resourcePolicy
//		// and then make assertions.
//
//	}
type resourcePolicyMock[Resource any, ResourceAttrs any] struct {
	// authorizeCreateFunc mocks the authorizeCreate method.
	authorizeCreateFunc func(ctx context.Context, authCtx AuthContext, attrs *ResourceAttrs) error

	// authorizeDeleteFunc mocks the authorizeDelete method.
	authorizeDeleteFunc func(ctx context.Context, authCtx AuthContext, resource *Resource) error

	// authorizeUpdateFunc mocks the authorizeUpdate method.
	authorizeUpdateFunc func(ctx context.Context, authCtx AuthContext, resource *Resource, attrs *ResourceAttrs) error

	// getManageScopeFunc mocks the getManageScope method.
	getManageScopeFunc func(authContext AuthContext) resourceScope[Resource]

	// getReadScopeFunc mocks the getReadScope method.
	getReadScopeFunc func(authContext AuthContext) resourceScope[Resource]

	// instancePermissionsFunc mocks the instancePermissions method.
	instancePermissionsFunc func(authContext AuthContext, v *Resource) ResourceInstancePermissions

	// permissionsFunc mocks the permissions method.
	permissionsFunc func(authContext AuthContext) ResourcePermissions

	// calls tracks calls to the methods.
	calls struct {
		// authorizeCreate holds details about calls to the authorizeCreate method.
		authorizeCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuthCtx is the authCtx argument value.
			AuthCtx AuthContext
			// Attrs is the attrs argument value.
			Attrs *ResourceAttrs
		}
		// authorizeDelete holds details about calls to the authorizeDelete method.
		authorizeDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuthCtx is the authCtx argument value.
			AuthCtx AuthContext
			// Resource is the resource argument value.
			Resource *Resource
		}
		// authorizeUpdate holds details about calls to the authorizeUpdate method.
		authorizeUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuthCtx is the authCtx argument value.
			AuthCtx AuthContext
			// Resource is the resource argument value.
			Resource *Resource
			// Attrs is the attrs argument value.
			Attrs *ResourceAttrs
		}
		// getManageScope holds details about calls to the getManageScope method.
		getManageScope []struct {
			// AuthContext is the authContext argument value.
			AuthContext AuthContext
		}
		// getReadScope holds details about calls to the getReadScope method.
		getReadScope []struct {
			// AuthContext is the authContext argument value.
			AuthContext AuthContext
		}
		// instancePermissions holds details about calls to the instancePermissions method.
		instancePermissions []struct {
			// AuthContext is the authContext argument value.
			AuthContext AuthContext
			// V is the v argument value.
			V *Resource
		}
		// permissions holds details about calls to the permissions method.
		permissions []struct {
			// AuthContext is the authContext argument value.
			AuthContext AuthContext
		}
	}
	lockauthorizeCreate     sync.RWMutex
	lockauthorizeDelete     sync.RWMutex
	lockauthorizeUpdate     sync.RWMutex
	lockgetManageScope      sync.RWMutex
	lockgetReadScope        sync.RWMutex
	lockinstancePermissions sync.RWMutex
	lockpermissions         sync.RWMutex
}

// authorizeCreate calls authorizeCreateFunc.
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) authorizeCreate(ctx context.Context, authCtx AuthContext, attrs *ResourceAttrs) error {
	if mock.authorizeCreateFunc == nil {
		panic("resourcePolicyMock.authorizeCreateFunc: method is nil but resourcePolicy.authorizeCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		AuthCtx AuthContext
		Attrs   *ResourceAttrs
	}{
		Ctx:     ctx,
		AuthCtx: authCtx,
		Attrs:   attrs,
	}
	mock.lockauthorizeCreate.Lock()
	mock.calls.authorizeCreate = append(mock.calls.authorizeCreate, callInfo)
	mock.lockauthorizeCreate.Unlock()
	return mock.authorizeCreateFunc(ctx, authCtx, attrs)
}

// authorizeCreateCalls gets all the calls that were made to authorizeCreate.
// Check the length with:
//
//	len(mockedresourcePolicy.authorizeCreateCalls())
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) authorizeCreateCalls() []struct {
	Ctx     context.Context
	AuthCtx AuthContext
	Attrs   *ResourceAttrs
} {
	var calls []struct {
		Ctx     context.Context
		AuthCtx AuthContext
		Attrs   *ResourceAttrs
	}
	mock.lockauthorizeCreate.RLock()
	calls = mock.calls.authorizeCreate
	mock.lockauthorizeCreate.RUnlock()
	return calls
}

// authorizeDelete calls authorizeDeleteFunc.
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) authorizeDelete(ctx context.Context, authCtx AuthContext, resource *Resource) error {
	if mock.authorizeDeleteFunc == nil {
		panic("resourcePolicyMock.authorizeDeleteFunc: method is nil but resourcePolicy.authorizeDelete was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		AuthCtx  AuthContext
		Resource *Resource
	}{
		Ctx:      ctx,
		AuthCtx:  authCtx,
		Resource: resource,
	}
	mock.lockauthorizeDelete.Lock()
	mock.calls.authorizeDelete = append(mock.calls.authorizeDelete, callInfo)
	mock.lockauthorizeDelete.Unlock()
	return mock.authorizeDeleteFunc(ctx, authCtx, resource)
}

// authorizeDeleteCalls gets all the calls that were made to authorizeDelete.
// Check the length with:
//
//	len(mockedresourcePolicy.authorizeDeleteCalls())
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) authorizeDeleteCalls() []struct {
	Ctx      context.Context
	AuthCtx  AuthContext
	Resource *Resource
} {
	var calls []struct {
		Ctx      context.Context
		AuthCtx  AuthContext
		Resource *Resource
	}
	mock.lockauthorizeDelete.RLock()
	calls = mock.calls.authorizeDelete
	mock.lockauthorizeDelete.RUnlock()
	return calls
}

// authorizeUpdate calls authorizeUpdateFunc.
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) authorizeUpdate(ctx context.Context, authCtx AuthContext, resource *Resource, attrs *ResourceAttrs) error {
	if mock.authorizeUpdateFunc == nil {
		panic("resourcePolicyMock.authorizeUpdateFunc: method is nil but resourcePolicy.authorizeUpdate was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		AuthCtx  AuthContext
		Resource *Resource
		Attrs    *ResourceAttrs
	}{
		Ctx:      ctx,
		AuthCtx:  authCtx,
		Resource: resource,
		Attrs:    attrs,
	}
	mock.lockauthorizeUpdate.Lock()
	mock.calls.authorizeUpdate = append(mock.calls.authorizeUpdate, callInfo)
	mock.lockauthorizeUpdate.Unlock()
	return mock.authorizeUpdateFunc(ctx, authCtx, resource, attrs)
}

// authorizeUpdateCalls gets all the calls that were made to authorizeUpdate.
// Check the length with:
//
//	len(mockedresourcePolicy.authorizeUpdateCalls())
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) authorizeUpdateCalls() []struct {
	Ctx      context.Context
	AuthCtx  AuthContext
	Resource *Resource
	Attrs    *ResourceAttrs
} {
	var calls []struct {
		Ctx      context.Context
		AuthCtx  AuthContext
		Resource *Resource
		Attrs    *ResourceAttrs
	}
	mock.lockauthorizeUpdate.RLock()
	calls = mock.calls.authorizeUpdate
	mock.lockauthorizeUpdate.RUnlock()
	return calls
}

// getManageScope calls getManageScopeFunc.
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) getManageScope(authContext AuthContext) resourceScope[Resource] {
	if mock.getManageScopeFunc == nil {
		panic("resourcePolicyMock.getManageScopeFunc: method is nil but resourcePolicy.getManageScope was just called")
	}
	callInfo := struct {
		AuthContext AuthContext
	}{
		AuthContext: authContext,
	}
	mock.lockgetManageScope.Lock()
	mock.calls.getManageScope = append(mock.calls.getManageScope, callInfo)
	mock.lockgetManageScope.Unlock()
	return mock.getManageScopeFunc(authContext)
}

// getManageScopeCalls gets all the calls that were made to getManageScope.
// Check the length with:
//
//	len(mockedresourcePolicy.getManageScopeCalls())
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) getManageScopeCalls() []struct {
	AuthContext AuthContext
} {
	var calls []struct {
		AuthContext AuthContext
	}
	mock.lockgetManageScope.RLock()
	calls = mock.calls.getManageScope
	mock.lockgetManageScope.RUnlock()
	return calls
}

// getReadScope calls getReadScopeFunc.
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) getReadScope(authContext AuthContext) resourceScope[Resource] {
	if mock.getReadScopeFunc == nil {
		panic("resourcePolicyMock.getReadScopeFunc: method is nil but resourcePolicy.getReadScope was just called")
	}
	callInfo := struct {
		AuthContext AuthContext
	}{
		AuthContext: authContext,
	}
	mock.lockgetReadScope.Lock()
	mock.calls.getReadScope = append(mock.calls.getReadScope, callInfo)
	mock.lockgetReadScope.Unlock()
	return mock.getReadScopeFunc(authContext)
}

// getReadScopeCalls gets all the calls that were made to getReadScope.
// Check the length with:
//
//	len(mockedresourcePolicy.getReadScopeCalls())
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) getReadScopeCalls() []struct {
	AuthContext AuthContext
} {
	var calls []struct {
		AuthContext AuthContext
	}
	mock.lockgetReadScope.RLock()
	calls = mock.calls.getReadScope
	mock.lockgetReadScope.RUnlock()
	return calls
}

// instancePermissions calls instancePermissionsFunc.
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) instancePermissions(authContext AuthContext, v *Resource) ResourceInstancePermissions {
	if mock.instancePermissionsFunc == nil {
		panic("resourcePolicyMock.instancePermissionsFunc: method is nil but resourcePolicy.instancePermissions was just called")
	}
	callInfo := struct {
		AuthContext AuthContext
		V           *Resource
	}{
		AuthContext: authContext,
		V:           v,
	}
	mock.lockinstancePermissions.Lock()
	mock.calls.instancePermissions = append(mock.calls.instancePermissions, callInfo)
	mock.lockinstancePermissions.Unlock()
	return mock.instancePermissionsFunc(authContext, v)
}

// instancePermissionsCalls gets all the calls that were made to instancePermissions.
// Check the length with:
//
//	len(mockedresourcePolicy.instancePermissionsCalls())
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) instancePermissionsCalls() []struct {
	AuthContext AuthContext
	V           *Resource
} {
	var calls []struct {
		AuthContext AuthContext
		V           *Resource
	}
	mock.lockinstancePermissions.RLock()
	calls = mock.calls.instancePermissions
	mock.lockinstancePermissions.RUnlock()
	return calls
}

// permissions calls permissionsFunc.
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) permissions(authContext AuthContext) ResourcePermissions {
	if mock.permissionsFunc == nil {
		panic("resourcePolicyMock.permissionsFunc: method is nil but resourcePolicy.permissions was just called")
	}
	callInfo := struct {
		AuthContext AuthContext
	}{
		AuthContext: authContext,
	}
	mock.lockpermissions.Lock()
	mock.calls.permissions = append(mock.calls.permissions, callInfo)
	mock.lockpermissions.Unlock()
	return mock.permissionsFunc(authContext)
}

// permissionsCalls gets all the calls that were made to permissions.
// Check the length with:
//
//	len(mockedresourcePolicy.permissionsCalls())
func (mock *resourcePolicyMock[Resource, ResourceAttrs]) permissionsCalls() []struct {
	AuthContext AuthContext
} {
	var calls []struct {
		AuthContext AuthContext
	}
	mock.lockpermissions.RLock()
	calls = mock.calls.permissions
	mock.lockpermissions.RUnlock()
	return calls
}

// Ensure, that resourceScopeMock does implement resourceScope.
// If this is not the case, regenerate this file with moq.
var _ resourceScope[any] = &resourceScopeMock[any]{}

// resourceScopeMock is a mock implementation of resourceScope.
//
//	func TestSomethingThatUsesresourceScope(t *testing.T) {
//
//		// make and configure a mocked resourceScope
//		mockedresourceScope := &resourceScopeMock{
//			findFunc: func(contextMoqParam context.Context, n int64) (*Resource, error) {
//				panic("mock out the find method")
//			},
//			listFunc: func(contextMoqParam context.Context) ([]Resource, error) {
//				panic("mock out the list method")
//			},
//		}
//
//		// use mockedresourceScope in code that requires resourceScope
//		// and then make assertions.
//
//	}
type resourceScopeMock[Resource any] struct {
	// findFunc mocks the find method.
	findFunc func(contextMoqParam context.Context, n int64) (*Resource, error)

	// listFunc mocks the list method.
	listFunc func(contextMoqParam context.Context) ([]Resource, error)

	// calls tracks calls to the methods.
	calls struct {
		// find holds details about calls to the find method.
		find []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// N is the n argument value.
			N int64
		}
		// list holds details about calls to the list method.
		list []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
	}
	lockfind sync.RWMutex
	locklist sync.RWMutex
}

// find calls findFunc.
func (mock *resourceScopeMock[Resource]) find(contextMoqParam context.Context, n int64) (*Resource, error) {
	if mock.findFunc == nil {
		panic("resourceScopeMock.findFunc: method is nil but resourceScope.find was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		N               int64
	}{
		ContextMoqParam: contextMoqParam,
		N:               n,
	}
	mock.lockfind.Lock()
	mock.calls.find = append(mock.calls.find, callInfo)
	mock.lockfind.Unlock()
	return mock.findFunc(contextMoqParam, n)
}

// findCalls gets all the calls that were made to find.
// Check the length with:
//
//	len(mockedresourceScope.findCalls())
func (mock *resourceScopeMock[Resource]) findCalls() []struct {
	ContextMoqParam context.Context
	N               int64
} {
	var calls []struct {
		ContextMoqParam context.Context
		N               int64
	}
	mock.lockfind.RLock()
	calls = mock.calls.find
	mock.lockfind.RUnlock()
	return calls
}

// list calls listFunc.
func (mock *resourceScopeMock[Resource]) list(contextMoqParam context.Context) ([]Resource, error) {
	if mock.listFunc == nil {
		panic("resourceScopeMock.listFunc: method is nil but resourceScope.list was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.locklist.Lock()
	mock.calls.list = append(mock.calls.list, callInfo)
	mock.locklist.Unlock()
	return mock.listFunc(contextMoqParam)
}

// listCalls gets all the calls that were made to list.
// Check the length with:
//
//	len(mockedresourceScope.listCalls())
func (mock *resourceScopeMock[Resource]) listCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.locklist.RLock()
	calls = mock.calls.list
	mock.locklist.RUnlock()
	return calls
}
