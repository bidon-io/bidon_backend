// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package admin

import (
	"context"
	"sync"
)

// Ensure, that ResourceManipulatorMock does implement ResourceManipulator.
// If this is not the case, regenerate this file with moq.
var _ ResourceManipulator[any, any] = &ResourceManipulatorMock[any, any]{}

// ResourceManipulatorMock is a mock implementation of ResourceManipulator.
//
//	func TestSomethingThatUsesResourceManipulator(t *testing.T) {
//
//		// make and configure a mocked ResourceManipulator
//		mockedResourceManipulator := &ResourceManipulatorMock{
//			CreateFunc: func(ctx context.Context, attrs *ResourceAttrs) (*Resource, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the Delete method")
//			},
//			UpdateFunc: func(ctx context.Context, id int64, attrs *ResourceAttrs) (*Resource, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedResourceManipulator in code that requires ResourceManipulator
//		// and then make assertions.
//
//	}
type ResourceManipulatorMock[Resource any, ResourceAttrs any] struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, attrs *ResourceAttrs) (*Resource, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id int64) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, id int64, attrs *ResourceAttrs) (*Resource, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attrs is the attrs argument value.
			Attrs *ResourceAttrs
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
			// Attrs is the attrs argument value.
			Attrs *ResourceAttrs
		}
	}
	lockCreate sync.RWMutex
	lockDelete sync.RWMutex
	lockUpdate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) Create(ctx context.Context, attrs *ResourceAttrs) (*Resource, error) {
	if mock.CreateFunc == nil {
		panic("ResourceManipulatorMock.CreateFunc: method is nil but ResourceManipulator.Create was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Attrs *ResourceAttrs
	}{
		Ctx:   ctx,
		Attrs: attrs,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, attrs)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedResourceManipulator.CreateCalls())
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) CreateCalls() []struct {
	Ctx   context.Context
	Attrs *ResourceAttrs
} {
	var calls []struct {
		Ctx   context.Context
		Attrs *ResourceAttrs
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) Delete(ctx context.Context, id int64) error {
	if mock.DeleteFunc == nil {
		panic("ResourceManipulatorMock.DeleteFunc: method is nil but ResourceManipulator.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedResourceManipulator.DeleteCalls())
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) DeleteCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) Update(ctx context.Context, id int64, attrs *ResourceAttrs) (*Resource, error) {
	if mock.UpdateFunc == nil {
		panic("ResourceManipulatorMock.UpdateFunc: method is nil but ResourceManipulator.Update was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		ID    int64
		Attrs *ResourceAttrs
	}{
		Ctx:   ctx,
		ID:    id,
		Attrs: attrs,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, id, attrs)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedResourceManipulator.UpdateCalls())
func (mock *ResourceManipulatorMock[Resource, ResourceAttrs]) UpdateCalls() []struct {
	Ctx   context.Context
	ID    int64
	Attrs *ResourceAttrs
} {
	var calls []struct {
		Ctx   context.Context
		ID    int64
		Attrs *ResourceAttrs
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that AuthContextMock does implement AuthContext.
// If this is not the case, regenerate this file with moq.
var _ AuthContext = &AuthContextMock{}

// AuthContextMock is a mock implementation of AuthContext.
//
//	func TestSomethingThatUsesAuthContext(t *testing.T) {
//
//		// make and configure a mocked AuthContext
//		mockedAuthContext := &AuthContextMock{
//			IsAdminFunc: func() bool {
//				panic("mock out the IsAdmin method")
//			},
//			UserIDFunc: func() int64 {
//				panic("mock out the UserID method")
//			},
//		}
//
//		// use mockedAuthContext in code that requires AuthContext
//		// and then make assertions.
//
//	}
type AuthContextMock struct {
	// IsAdminFunc mocks the IsAdmin method.
	IsAdminFunc func() bool

	// UserIDFunc mocks the UserID method.
	UserIDFunc func() int64

	// calls tracks calls to the methods.
	calls struct {
		// IsAdmin holds details about calls to the IsAdmin method.
		IsAdmin []struct {
		}
		// UserID holds details about calls to the UserID method.
		UserID []struct {
		}
	}
	lockIsAdmin sync.RWMutex
	lockUserID  sync.RWMutex
}

// IsAdmin calls IsAdminFunc.
func (mock *AuthContextMock) IsAdmin() bool {
	if mock.IsAdminFunc == nil {
		panic("AuthContextMock.IsAdminFunc: method is nil but AuthContext.IsAdmin was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsAdmin.Lock()
	mock.calls.IsAdmin = append(mock.calls.IsAdmin, callInfo)
	mock.lockIsAdmin.Unlock()
	return mock.IsAdminFunc()
}

// IsAdminCalls gets all the calls that were made to IsAdmin.
// Check the length with:
//
//	len(mockedAuthContext.IsAdminCalls())
func (mock *AuthContextMock) IsAdminCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsAdmin.RLock()
	calls = mock.calls.IsAdmin
	mock.lockIsAdmin.RUnlock()
	return calls
}

// UserID calls UserIDFunc.
func (mock *AuthContextMock) UserID() int64 {
	if mock.UserIDFunc == nil {
		panic("AuthContextMock.UserIDFunc: method is nil but AuthContext.UserID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUserID.Lock()
	mock.calls.UserID = append(mock.calls.UserID, callInfo)
	mock.lockUserID.Unlock()
	return mock.UserIDFunc()
}

// UserIDCalls gets all the calls that were made to UserID.
// Check the length with:
//
//	len(mockedAuthContext.UserIDCalls())
func (mock *AuthContextMock) UserIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUserID.RLock()
	calls = mock.calls.UserID
	mock.lockUserID.RUnlock()
	return calls
}

// Ensure, that resourcePolicyMock does implement resourcePolicy.
// If this is not the case, regenerate this file with moq.
var _ resourcePolicy[any] = &resourcePolicyMock[any]{}

// resourcePolicyMock is a mock implementation of resourcePolicy.
//
//	func TestSomethingThatUsesresourcePolicy(t *testing.T) {
//
//		// make and configure a mocked resourcePolicy
//		mockedresourcePolicy := &resourcePolicyMock{
//			scopeFunc: func(authContext AuthContext) resourceScope[Resource] {
//				panic("mock out the scope method")
//			},
//		}
//
//		// use mockedresourcePolicy in code that requires resourcePolicy
//		// and then make assertions.
//
//	}
type resourcePolicyMock[Resource any] struct {
	// scopeFunc mocks the scope method.
	scopeFunc func(authContext AuthContext) resourceScope[Resource]

	// calls tracks calls to the methods.
	calls struct {
		// scope holds details about calls to the scope method.
		scope []struct {
			// AuthContext is the authContext argument value.
			AuthContext AuthContext
		}
	}
	lockscope sync.RWMutex
}

// scope calls scopeFunc.
func (mock *resourcePolicyMock[Resource]) scope(authContext AuthContext) resourceScope[Resource] {
	if mock.scopeFunc == nil {
		panic("resourcePolicyMock.scopeFunc: method is nil but resourcePolicy.scope was just called")
	}
	callInfo := struct {
		AuthContext AuthContext
	}{
		AuthContext: authContext,
	}
	mock.lockscope.Lock()
	mock.calls.scope = append(mock.calls.scope, callInfo)
	mock.lockscope.Unlock()
	return mock.scopeFunc(authContext)
}

// scopeCalls gets all the calls that were made to scope.
// Check the length with:
//
//	len(mockedresourcePolicy.scopeCalls())
func (mock *resourcePolicyMock[Resource]) scopeCalls() []struct {
	AuthContext AuthContext
} {
	var calls []struct {
		AuthContext AuthContext
	}
	mock.lockscope.RLock()
	calls = mock.calls.scope
	mock.lockscope.RUnlock()
	return calls
}

// Ensure, that resourceScopeMock does implement resourceScope.
// If this is not the case, regenerate this file with moq.
var _ resourceScope[any] = &resourceScopeMock[any]{}

// resourceScopeMock is a mock implementation of resourceScope.
//
//	func TestSomethingThatUsesresourceScope(t *testing.T) {
//
//		// make and configure a mocked resourceScope
//		mockedresourceScope := &resourceScopeMock{
//			findFunc: func(contextMoqParam context.Context, n int64) (*Resource, error) {
//				panic("mock out the find method")
//			},
//			listFunc: func(contextMoqParam context.Context) ([]Resource, error) {
//				panic("mock out the list method")
//			},
//		}
//
//		// use mockedresourceScope in code that requires resourceScope
//		// and then make assertions.
//
//	}
type resourceScopeMock[Resource any] struct {
	// findFunc mocks the find method.
	findFunc func(contextMoqParam context.Context, n int64) (*Resource, error)

	// listFunc mocks the list method.
	listFunc func(contextMoqParam context.Context) ([]Resource, error)

	// calls tracks calls to the methods.
	calls struct {
		// find holds details about calls to the find method.
		find []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// N is the n argument value.
			N int64
		}
		// list holds details about calls to the list method.
		list []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
	}
	lockfind sync.RWMutex
	locklist sync.RWMutex
}

// find calls findFunc.
func (mock *resourceScopeMock[Resource]) find(contextMoqParam context.Context, n int64) (*Resource, error) {
	if mock.findFunc == nil {
		panic("resourceScopeMock.findFunc: method is nil but resourceScope.find was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		N               int64
	}{
		ContextMoqParam: contextMoqParam,
		N:               n,
	}
	mock.lockfind.Lock()
	mock.calls.find = append(mock.calls.find, callInfo)
	mock.lockfind.Unlock()
	return mock.findFunc(contextMoqParam, n)
}

// findCalls gets all the calls that were made to find.
// Check the length with:
//
//	len(mockedresourceScope.findCalls())
func (mock *resourceScopeMock[Resource]) findCalls() []struct {
	ContextMoqParam context.Context
	N               int64
} {
	var calls []struct {
		ContextMoqParam context.Context
		N               int64
	}
	mock.lockfind.RLock()
	calls = mock.calls.find
	mock.lockfind.RUnlock()
	return calls
}

// list calls listFunc.
func (mock *resourceScopeMock[Resource]) list(contextMoqParam context.Context) ([]Resource, error) {
	if mock.listFunc == nil {
		panic("resourceScopeMock.listFunc: method is nil but resourceScope.list was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.locklist.Lock()
	mock.calls.list = append(mock.calls.list, callInfo)
	mock.locklist.Unlock()
	return mock.listFunc(contextMoqParam)
}

// listCalls gets all the calls that were made to list.
// Check the length with:
//
//	len(mockedresourceScope.listCalls())
func (mock *resourceScopeMock[Resource]) listCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.locklist.RLock()
	calls = mock.calls.list
	mock.locklist.RUnlock()
	return calls
}
