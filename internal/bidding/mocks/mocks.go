// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bidon-io/bidon-backend/internal/adapter"
	"github.com/bidon-io/bidon-backend/internal/bidding"
	"github.com/bidon-io/bidon-backend/internal/bidding/adapters"
	"github.com/bidon-io/bidon-backend/internal/sdkapi/schema"
	"sync"
)

// Ensure, that AdaptersBuilderMock does implement bidding.AdaptersBuilder.
// If this is not the case, regenerate this file with moq.
var _ bidding.AdaptersBuilder = &AdaptersBuilderMock{}

// AdaptersBuilderMock is a mock implementation of bidding.AdaptersBuilder.
//
//	func TestSomethingThatUsesAdaptersBuilder(t *testing.T) {
//
//		// make and configure a mocked bidding.AdaptersBuilder
//		mockedAdaptersBuilder := &AdaptersBuilderMock{
//			BuildFunc: func(adapterKey adapter.Key, cfg adapter.ProcessedConfigsMap) (*adapters.Bidder, error) {
//				panic("mock out the Build method")
//			},
//		}
//
//		// use mockedAdaptersBuilder in code that requires bidding.AdaptersBuilder
//		// and then make assertions.
//
//	}
type AdaptersBuilderMock struct {
	// BuildFunc mocks the Build method.
	BuildFunc func(adapterKey adapter.Key, cfg adapter.ProcessedConfigsMap) (*adapters.Bidder, error)

	// calls tracks calls to the methods.
	calls struct {
		// Build holds details about calls to the Build method.
		Build []struct {
			// AdapterKey is the adapterKey argument value.
			AdapterKey adapter.Key
			// Cfg is the cfg argument value.
			Cfg adapter.ProcessedConfigsMap
		}
	}
	lockBuild sync.RWMutex
}

// Build calls BuildFunc.
func (mock *AdaptersBuilderMock) Build(adapterKey adapter.Key, cfg adapter.ProcessedConfigsMap) (*adapters.Bidder, error) {
	if mock.BuildFunc == nil {
		panic("AdaptersBuilderMock.BuildFunc: method is nil but AdaptersBuilder.Build was just called")
	}
	callInfo := struct {
		AdapterKey adapter.Key
		Cfg        adapter.ProcessedConfigsMap
	}{
		AdapterKey: adapterKey,
		Cfg:        cfg,
	}
	mock.lockBuild.Lock()
	mock.calls.Build = append(mock.calls.Build, callInfo)
	mock.lockBuild.Unlock()
	return mock.BuildFunc(adapterKey, cfg)
}

// BuildCalls gets all the calls that were made to Build.
// Check the length with:
//
//	len(mockedAdaptersBuilder.BuildCalls())
func (mock *AdaptersBuilderMock) BuildCalls() []struct {
	AdapterKey adapter.Key
	Cfg        adapter.ProcessedConfigsMap
} {
	var calls []struct {
		AdapterKey adapter.Key
		Cfg        adapter.ProcessedConfigsMap
	}
	mock.lockBuild.RLock()
	calls = mock.calls.Build
	mock.lockBuild.RUnlock()
	return calls
}

// Ensure, that NotificationHandlerMock does implement bidding.NotificationHandler.
// If this is not the case, regenerate this file with moq.
var _ bidding.NotificationHandler = &NotificationHandlerMock{}

// NotificationHandlerMock is a mock implementation of bidding.NotificationHandler.
//
//	func TestSomethingThatUsesNotificationHandler(t *testing.T) {
//
//		// make and configure a mocked bidding.NotificationHandler
//		mockedNotificationHandler := &NotificationHandlerMock{
//			HandleBiddingRoundFunc: func(contextMoqParam context.Context, adObject *schema.AdObject, auctionResult bidding.AuctionResult, s1 string, s2 string) error {
//				panic("mock out the HandleBiddingRound method")
//			},
//		}
//
//		// use mockedNotificationHandler in code that requires bidding.NotificationHandler
//		// and then make assertions.
//
//	}
type NotificationHandlerMock struct {
	// HandleBiddingRoundFunc mocks the HandleBiddingRound method.
	HandleBiddingRoundFunc func(contextMoqParam context.Context, adObject *schema.AdObject, auctionResult bidding.AuctionResult, s1 string, s2 string) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleBiddingRound holds details about calls to the HandleBiddingRound method.
		HandleBiddingRound []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// AdObject is the adObject argument value.
			AdObject *schema.AdObject
			// AuctionResult is the auctionResult argument value.
			AuctionResult bidding.AuctionResult
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
	}
	lockHandleBiddingRound sync.RWMutex
}

// HandleBiddingRound calls HandleBiddingRoundFunc.
func (mock *NotificationHandlerMock) HandleBiddingRound(contextMoqParam context.Context, adObject *schema.AdObject, auctionResult bidding.AuctionResult, s1 string, s2 string) error {
	if mock.HandleBiddingRoundFunc == nil {
		panic("NotificationHandlerMock.HandleBiddingRoundFunc: method is nil but NotificationHandler.HandleBiddingRound was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		AdObject        *schema.AdObject
		AuctionResult   bidding.AuctionResult
		S1              string
		S2              string
	}{
		ContextMoqParam: contextMoqParam,
		AdObject:        adObject,
		AuctionResult:   auctionResult,
		S1:              s1,
		S2:              s2,
	}
	mock.lockHandleBiddingRound.Lock()
	mock.calls.HandleBiddingRound = append(mock.calls.HandleBiddingRound, callInfo)
	mock.lockHandleBiddingRound.Unlock()
	return mock.HandleBiddingRoundFunc(contextMoqParam, adObject, auctionResult, s1, s2)
}

// HandleBiddingRoundCalls gets all the calls that were made to HandleBiddingRound.
// Check the length with:
//
//	len(mockedNotificationHandler.HandleBiddingRoundCalls())
func (mock *NotificationHandlerMock) HandleBiddingRoundCalls() []struct {
	ContextMoqParam context.Context
	AdObject        *schema.AdObject
	AuctionResult   bidding.AuctionResult
	S1              string
	S2              string
} {
	var calls []struct {
		ContextMoqParam context.Context
		AdObject        *schema.AdObject
		AuctionResult   bidding.AuctionResult
		S1              string
		S2              string
	}
	mock.lockHandleBiddingRound.RLock()
	calls = mock.calls.HandleBiddingRound
	mock.lockHandleBiddingRound.RUnlock()
	return calls
}

// Ensure, that BidCacherMock does implement bidding.BidCacher.
// If this is not the case, regenerate this file with moq.
var _ bidding.BidCacher = &BidCacherMock{}

// BidCacherMock is a mock implementation of bidding.BidCacher.
//
//	func TestSomethingThatUsesBidCacher(t *testing.T) {
//
//		// make and configure a mocked bidding.BidCacher
//		mockedBidCacher := &BidCacherMock{
//			ApplyBidCacheFunc: func(ctx context.Context, ar *schema.AuctionRequest, result *bidding.AuctionResult) []adapters.DemandResponse {
//				panic("mock out the ApplyBidCache method")
//			},
//		}
//
//		// use mockedBidCacher in code that requires bidding.BidCacher
//		// and then make assertions.
//
//	}
type BidCacherMock struct {
	// ApplyBidCacheFunc mocks the ApplyBidCache method.
	ApplyBidCacheFunc func(ctx context.Context, ar *schema.AuctionRequest, result *bidding.AuctionResult) []adapters.DemandResponse

	// calls tracks calls to the methods.
	calls struct {
		// ApplyBidCache holds details about calls to the ApplyBidCache method.
		ApplyBidCache []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ar is the ar argument value.
			Ar *schema.AuctionRequest
			// Result is the result argument value.
			Result *bidding.AuctionResult
		}
	}
	lockApplyBidCache sync.RWMutex
}

// ApplyBidCache calls ApplyBidCacheFunc.
func (mock *BidCacherMock) ApplyBidCache(ctx context.Context, ar *schema.AuctionRequest, result *bidding.AuctionResult) []adapters.DemandResponse {
	if mock.ApplyBidCacheFunc == nil {
		panic("BidCacherMock.ApplyBidCacheFunc: method is nil but BidCacher.ApplyBidCache was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ar     *schema.AuctionRequest
		Result *bidding.AuctionResult
	}{
		Ctx:    ctx,
		Ar:     ar,
		Result: result,
	}
	mock.lockApplyBidCache.Lock()
	mock.calls.ApplyBidCache = append(mock.calls.ApplyBidCache, callInfo)
	mock.lockApplyBidCache.Unlock()
	return mock.ApplyBidCacheFunc(ctx, ar, result)
}

// ApplyBidCacheCalls gets all the calls that were made to ApplyBidCache.
// Check the length with:
//
//	len(mockedBidCacher.ApplyBidCacheCalls())
func (mock *BidCacherMock) ApplyBidCacheCalls() []struct {
	Ctx    context.Context
	Ar     *schema.AuctionRequest
	Result *bidding.AuctionResult
} {
	var calls []struct {
		Ctx    context.Context
		Ar     *schema.AuctionRequest
		Result *bidding.AuctionResult
	}
	mock.lockApplyBidCache.RLock()
	calls = mock.calls.ApplyBidCache
	mock.lockApplyBidCache.RUnlock()
	return calls
}
