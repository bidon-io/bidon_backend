// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bidon-io/bidon-backend/internal/notification"
	"github.com/bidon-io/bidon-backend/internal/sdkapi/schema"
	"sync"
)

// Ensure, that AuctionResultRepoMock does implement notification.AuctionResultRepo.
// If this is not the case, regenerate this file with moq.
var _ notification.AuctionResultRepo = &AuctionResultRepoMock{}

// AuctionResultRepoMock is a mock implementation of notification.AuctionResultRepo.
//
//	func TestSomethingThatUsesAuctionResultRepo(t *testing.T) {
//
//		// make and configure a mocked notification.AuctionResultRepo
//		mockedAuctionResultRepo := &AuctionResultRepoMock{
//			CreateOrUpdateFunc: func(ctx context.Context, imp *schema.Imp, bids []notification.Bid) error {
//				panic("mock out the CreateOrUpdate method")
//			},
//			FindFunc: func(ctx context.Context, auctionID string) (*notification.AuctionResult, error) {
//				panic("mock out the Find method")
//			},
//		}
//
//		// use mockedAuctionResultRepo in code that requires notification.AuctionResultRepo
//		// and then make assertions.
//
//	}
type AuctionResultRepoMock struct {
	// CreateOrUpdateFunc mocks the CreateOrUpdate method.
	CreateOrUpdateFunc func(ctx context.Context, imp *schema.Imp, bids []notification.Bid) error

	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, auctionID string) (*notification.AuctionResult, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateOrUpdate holds details about calls to the CreateOrUpdate method.
		CreateOrUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Imp is the imp argument value.
			Imp *schema.Imp
			// Bids is the bids argument value.
			Bids []notification.Bid
		}
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuctionID is the auctionID argument value.
			AuctionID string
		}
	}
	lockCreateOrUpdate sync.RWMutex
	lockFind           sync.RWMutex
}

// CreateOrUpdate calls CreateOrUpdateFunc.
func (mock *AuctionResultRepoMock) CreateOrUpdate(ctx context.Context, imp *schema.Imp, bids []notification.Bid) error {
	if mock.CreateOrUpdateFunc == nil {
		panic("AuctionResultRepoMock.CreateOrUpdateFunc: method is nil but AuctionResultRepo.CreateOrUpdate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Imp  *schema.Imp
		Bids []notification.Bid
	}{
		Ctx:  ctx,
		Imp:  imp,
		Bids: bids,
	}
	mock.lockCreateOrUpdate.Lock()
	mock.calls.CreateOrUpdate = append(mock.calls.CreateOrUpdate, callInfo)
	mock.lockCreateOrUpdate.Unlock()
	return mock.CreateOrUpdateFunc(ctx, imp, bids)
}

// CreateOrUpdateCalls gets all the calls that were made to CreateOrUpdate.
// Check the length with:
//
//	len(mockedAuctionResultRepo.CreateOrUpdateCalls())
func (mock *AuctionResultRepoMock) CreateOrUpdateCalls() []struct {
	Ctx  context.Context
	Imp  *schema.Imp
	Bids []notification.Bid
} {
	var calls []struct {
		Ctx  context.Context
		Imp  *schema.Imp
		Bids []notification.Bid
	}
	mock.lockCreateOrUpdate.RLock()
	calls = mock.calls.CreateOrUpdate
	mock.lockCreateOrUpdate.RUnlock()
	return calls
}

// Find calls FindFunc.
func (mock *AuctionResultRepoMock) Find(ctx context.Context, auctionID string) (*notification.AuctionResult, error) {
	if mock.FindFunc == nil {
		panic("AuctionResultRepoMock.FindFunc: method is nil but AuctionResultRepo.Find was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AuctionID string
	}{
		Ctx:       ctx,
		AuctionID: auctionID,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, auctionID)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedAuctionResultRepo.FindCalls())
func (mock *AuctionResultRepoMock) FindCalls() []struct {
	Ctx       context.Context
	AuctionID string
} {
	var calls []struct {
		Ctx       context.Context
		AuctionID string
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// Ensure, that SenderMock does implement notification.Sender.
// If this is not the case, regenerate this file with moq.
var _ notification.Sender = &SenderMock{}

// SenderMock is a mock implementation of notification.Sender.
//
//	func TestSomethingThatUsesSender(t *testing.T) {
//
//		// make and configure a mocked notification.Sender
//		mockedSender := &SenderMock{
//			SendEventFunc: func(ctx context.Context, p notification.Params)  {
//				panic("mock out the SendEvent method")
//			},
//		}
//
//		// use mockedSender in code that requires notification.Sender
//		// and then make assertions.
//
//	}
type SenderMock struct {
	// SendEventFunc mocks the SendEvent method.
	SendEventFunc func(ctx context.Context, p notification.Params)

	// calls tracks calls to the methods.
	calls struct {
		// SendEvent holds details about calls to the SendEvent method.
		SendEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// P is the p argument value.
			P notification.Params
		}
	}
	lockSendEvent sync.RWMutex
}

// SendEvent calls SendEventFunc.
func (mock *SenderMock) SendEvent(ctx context.Context, p notification.Params) {
	if mock.SendEventFunc == nil {
		panic("SenderMock.SendEventFunc: method is nil but Sender.SendEvent was just called")
	}
	callInfo := struct {
		Ctx context.Context
		P   notification.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSendEvent.Lock()
	mock.calls.SendEvent = append(mock.calls.SendEvent, callInfo)
	mock.lockSendEvent.Unlock()
	mock.SendEventFunc(ctx, p)
}

// SendEventCalls gets all the calls that were made to SendEvent.
// Check the length with:
//
//	len(mockedSender.SendEventCalls())
func (mock *SenderMock) SendEventCalls() []struct {
	Ctx context.Context
	P   notification.Params
} {
	var calls []struct {
		Ctx context.Context
		P   notification.Params
	}
	mock.lockSendEvent.RLock()
	calls = mock.calls.SendEvent
	mock.lockSendEvent.RUnlock()
	return calls
}
