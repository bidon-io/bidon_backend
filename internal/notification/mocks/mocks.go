// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bidon-io/bidon-backend/internal/auction"
	"github.com/bidon-io/bidon-backend/internal/notification"
	"github.com/bidon-io/bidon-backend/internal/sdkapi/schema"
	"sync"
)

// Ensure, that AuctionResultRepoMock does implement notification.AuctionResultRepo.
// If this is not the case, regenerate this file with moq.
var _ notification.AuctionResultRepo = &AuctionResultRepoMock{}

// AuctionResultRepoMock is a mock implementation of notification.AuctionResultRepo.
//
//	func TestSomethingThatUsesAuctionResultRepo(t *testing.T) {
//
//		// make and configure a mocked notification.AuctionResultRepo
//		mockedAuctionResultRepo := &AuctionResultRepoMock{
//			CreateOrUpdateFunc: func(ctx context.Context, adObject *schema.AdObject, bids []notification.Bid) error {
//				panic("mock out the CreateOrUpdate method")
//			},
//			FindFunc: func(ctx context.Context, auctionID string) (*notification.AuctionResult, error) {
//				panic("mock out the Find method")
//			},
//		}
//
//		// use mockedAuctionResultRepo in code that requires notification.AuctionResultRepo
//		// and then make assertions.
//
//	}
type AuctionResultRepoMock struct {
	// CreateOrUpdateFunc mocks the CreateOrUpdate method.
	CreateOrUpdateFunc func(ctx context.Context, adObject *schema.AdObject, bids []notification.Bid) error

	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, auctionID string) (*notification.AuctionResult, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateOrUpdate holds details about calls to the CreateOrUpdate method.
		CreateOrUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AdObject is the adObject argument value.
			AdObject *schema.AdObject
			// Bids is the bids argument value.
			Bids []notification.Bid
		}
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuctionID is the auctionID argument value.
			AuctionID string
		}
	}
	lockCreateOrUpdate sync.RWMutex
	lockFind           sync.RWMutex
}

// CreateOrUpdate calls CreateOrUpdateFunc.
func (mock *AuctionResultRepoMock) CreateOrUpdate(ctx context.Context, adObject *schema.AdObject, bids []notification.Bid) error {
	if mock.CreateOrUpdateFunc == nil {
		panic("AuctionResultRepoMock.CreateOrUpdateFunc: method is nil but AuctionResultRepo.CreateOrUpdate was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		AdObject *schema.AdObject
		Bids     []notification.Bid
	}{
		Ctx:      ctx,
		AdObject: adObject,
		Bids:     bids,
	}
	mock.lockCreateOrUpdate.Lock()
	mock.calls.CreateOrUpdate = append(mock.calls.CreateOrUpdate, callInfo)
	mock.lockCreateOrUpdate.Unlock()
	return mock.CreateOrUpdateFunc(ctx, adObject, bids)
}

// CreateOrUpdateCalls gets all the calls that were made to CreateOrUpdate.
// Check the length with:
//
//	len(mockedAuctionResultRepo.CreateOrUpdateCalls())
func (mock *AuctionResultRepoMock) CreateOrUpdateCalls() []struct {
	Ctx      context.Context
	AdObject *schema.AdObject
	Bids     []notification.Bid
} {
	var calls []struct {
		Ctx      context.Context
		AdObject *schema.AdObject
		Bids     []notification.Bid
	}
	mock.lockCreateOrUpdate.RLock()
	calls = mock.calls.CreateOrUpdate
	mock.lockCreateOrUpdate.RUnlock()
	return calls
}

// Find calls FindFunc.
func (mock *AuctionResultRepoMock) Find(ctx context.Context, auctionID string) (*notification.AuctionResult, error) {
	if mock.FindFunc == nil {
		panic("AuctionResultRepoMock.FindFunc: method is nil but AuctionResultRepo.Find was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AuctionID string
	}{
		Ctx:       ctx,
		AuctionID: auctionID,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, auctionID)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedAuctionResultRepo.FindCalls())
func (mock *AuctionResultRepoMock) FindCalls() []struct {
	Ctx       context.Context
	AuctionID string
} {
	var calls []struct {
		Ctx       context.Context
		AuctionID string
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// Ensure, that SenderMock does implement notification.Sender.
// If this is not the case, regenerate this file with moq.
var _ notification.Sender = &SenderMock{}

// SenderMock is a mock implementation of notification.Sender.
//
//	func TestSomethingThatUsesSender(t *testing.T) {
//
//		// make and configure a mocked notification.Sender
//		mockedSender := &SenderMock{
//			SendEventFunc: func(ctx context.Context, p notification.Params)  {
//				panic("mock out the SendEvent method")
//			},
//		}
//
//		// use mockedSender in code that requires notification.Sender
//		// and then make assertions.
//
//	}
type SenderMock struct {
	// SendEventFunc mocks the SendEvent method.
	SendEventFunc func(ctx context.Context, p notification.Params)

	// calls tracks calls to the methods.
	calls struct {
		// SendEvent holds details about calls to the SendEvent method.
		SendEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// P is the p argument value.
			P notification.Params
		}
	}
	lockSendEvent sync.RWMutex
}

// SendEvent calls SendEventFunc.
func (mock *SenderMock) SendEvent(ctx context.Context, p notification.Params) {
	if mock.SendEventFunc == nil {
		panic("SenderMock.SendEventFunc: method is nil but Sender.SendEvent was just called")
	}
	callInfo := struct {
		Ctx context.Context
		P   notification.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSendEvent.Lock()
	mock.calls.SendEvent = append(mock.calls.SendEvent, callInfo)
	mock.lockSendEvent.Unlock()
	mock.SendEventFunc(ctx, p)
}

// SendEventCalls gets all the calls that were made to SendEvent.
// Check the length with:
//
//	len(mockedSender.SendEventCalls())
func (mock *SenderMock) SendEventCalls() []struct {
	Ctx context.Context
	P   notification.Params
} {
	var calls []struct {
		Ctx context.Context
		P   notification.Params
	}
	mock.lockSendEvent.RLock()
	calls = mock.calls.SendEvent
	mock.lockSendEvent.RUnlock()
	return calls
}

// Ensure, that ConfigFetcherMock does implement notification.ConfigFetcher.
// If this is not the case, regenerate this file with moq.
var _ notification.ConfigFetcher = &ConfigFetcherMock{}

// ConfigFetcherMock is a mock implementation of notification.ConfigFetcher.
//
//	func TestSomethingThatUsesConfigFetcher(t *testing.T) {
//
//		// make and configure a mocked notification.ConfigFetcher
//		mockedConfigFetcher := &ConfigFetcherMock{
//			FetchByUIDCachedFunc: func(ctx context.Context, appID int64, id string, uid string) *auction.Config {
//				panic("mock out the FetchByUIDCached method")
//			},
//		}
//
//		// use mockedConfigFetcher in code that requires notification.ConfigFetcher
//		// and then make assertions.
//
//	}
type ConfigFetcherMock struct {
	// FetchByUIDCachedFunc mocks the FetchByUIDCached method.
	FetchByUIDCachedFunc func(ctx context.Context, appID int64, id string, uid string) *auction.Config

	// calls tracks calls to the methods.
	calls struct {
		// FetchByUIDCached holds details about calls to the FetchByUIDCached method.
		FetchByUIDCached []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AppID is the appID argument value.
			AppID int64
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
	}
	lockFetchByUIDCached sync.RWMutex
}

// FetchByUIDCached calls FetchByUIDCachedFunc.
func (mock *ConfigFetcherMock) FetchByUIDCached(ctx context.Context, appID int64, id string, uid string) *auction.Config {
	if mock.FetchByUIDCachedFunc == nil {
		panic("ConfigFetcherMock.FetchByUIDCachedFunc: method is nil but ConfigFetcher.FetchByUIDCached was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		AppID int64
		ID    string
		UID   string
	}{
		Ctx:   ctx,
		AppID: appID,
		ID:    id,
		UID:   uid,
	}
	mock.lockFetchByUIDCached.Lock()
	mock.calls.FetchByUIDCached = append(mock.calls.FetchByUIDCached, callInfo)
	mock.lockFetchByUIDCached.Unlock()
	return mock.FetchByUIDCachedFunc(ctx, appID, id, uid)
}

// FetchByUIDCachedCalls gets all the calls that were made to FetchByUIDCached.
// Check the length with:
//
//	len(mockedConfigFetcher.FetchByUIDCachedCalls())
func (mock *ConfigFetcherMock) FetchByUIDCachedCalls() []struct {
	Ctx   context.Context
	AppID int64
	ID    string
	UID   string
} {
	var calls []struct {
		Ctx   context.Context
		AppID int64
		ID    string
		UID   string
	}
	mock.lockFetchByUIDCached.RLock()
	calls = mock.calls.FetchByUIDCached
	mock.lockFetchByUIDCached.RUnlock()
	return calls
}
